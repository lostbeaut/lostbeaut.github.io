<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恋人心</title>
  
  
  <link href="http://xiaomengk.com/atom.xml" rel="self"/>
  
  <link href="http://xiaomengk.com/"/>
  <updated>2022-05-23T13:14:10.165Z</updated>
  <id>http://xiaomengk.com/</id>
  
  <author>
    <name>恋人心</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>恋人心</title>
    <link href="http://xiaomengk.com/2022/05/23/%E6%81%8B%E4%BA%BA%E5%BF%83/"/>
    <id>http://xiaomengk.com/2022/05/23/%E6%81%8B%E4%BA%BA%E5%BF%83/</id>
    <published>2022-05-23T13:12:28.000Z</published>
    <updated>2022-05-23T13:14:10.165Z</updated>
    
    <content type="html"><![CDATA[<pre><code>             适合自己才是最好的</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;             适合自己才是最好的
&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rtt 内核之重要数据结构</title>
    <link href="http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-05-22T13:57:38.000Z</published>
    <updated>2022-05-22T13:59:00.328Z</updated>
    
    <content type="html"><![CDATA[<ol><li>内核对象<br>&#x2F;**</li></ol><ul><li>The object type can be one of the follows with specific</li><li>macros enabled:</li><li><ul><li>Thread</li></ul></li><li><ul><li>Semaphore</li></ul></li><li><ul><li>Mutex</li></ul></li><li><ul><li>Event</li></ul></li><li><ul><li>MailBox</li></ul></li><li><ul><li>MessageQueue</li></ul></li><li><ul><li>MemHeap</li></ul></li><li><ul><li>MemPool</li></ul></li><li><ul><li>Device</li></ul></li><li><ul><li>Timer</li></ul></li><li><ul><li>Module</li></ul></li><li><ul><li>Unknown</li></ul></li><li><ul><li>Static<br> <em>&#x2F;<br>enum rt_object_class_type<br>{<br>RT_Object_Class_Null   &#x3D; 0,                         &#x2F;<em>*&lt; The object is not used. *&#x2F;<br>RT_Object_Class_Thread,                             &#x2F;**&lt; The object is a thread.       线程</em>&#x2F;<br>RT_Object_Class_Semaphore,                          &#x2F;**&lt; The object is a semaphore.    信号量</em>&#x2F;<br>RT_Object_Class_Mutex,                              &#x2F;<em>*&lt; The object is a mutex.        互斥量 *&#x2F;<br>RT_Object_Class_Event,                              &#x2F;**&lt; The object is a event.        事件</em>&#x2F;<br>RT_Object_Class_MailBox,                            &#x2F;<em><em>&lt; The object is a mail box.     邮箱</em>&#x2F;<br>RT_Object_Class_MessageQueue,                       &#x2F;</em>*&lt; The object is a message queue.消息队列 *&#x2F;<br>RT_Object_Class_MemHeap,                            &#x2F;<strong>&lt; The object is a memory heap *&#x2F;<br>RT_Object_Class_MemPool,                            &#x2F;**&lt; The object is a memory pool. *&#x2F;<br>RT_Object_Class_Device,                             &#x2F;</strong>&lt; The object is a device *&#x2F;<br>RT_Object_Class_Timer,                              &#x2F;<strong>&lt; The object is a timer. *&#x2F;<br>RT_Object_Class_Module,                             &#x2F;**&lt; The object is a module. *&#x2F;<br>RT_Object_Class_Unknown,                            &#x2F;</strong>&lt; The object is unknown. *&#x2F;<br>RT_Object_Class_Static &#x3D; 0x80                       &#x2F;**&lt; The object is a static object. *&#x2F;<br>};</li></ul></li></ul><p>2 .双向链表 </p><p>&#x2F;**</p><ul><li>Double List structure<br> *&#x2F;<br>struct rt_list_node<br>{<br> struct rt_list_node *next;                          &#x2F;<em>*&lt; point to next node. 前节点 *&#x2F;<br> struct rt_list_node <em>prev;                          &#x2F;**&lt; point to prev node. 后节点</em>&#x2F;<br>};<br>typedef struct rt_list_node rt_list_t;                  &#x2F;</em>*&lt; Type for lists. *&#x2F;</li></ul><ol start="3"><li>内核对象</li></ol><p>&#x2F;**</p><ul><li>Base structure of Kernel object<br> <em>&#x2F;<br>struct rt_object<br>{<br> char       name[RT_NAME_MAX];                       &#x2F;**&lt; name of kernel object  名字</em>&#x2F;<br> rt_uint8_t type;                                    &#x2F;<em><em>&lt; type of kernel object  内核对象类型</em>&#x2F;<br> rt_uint8_t flag;                                    &#x2F;</em><em>&lt; flag of kernel object  标志</em>&#x2F;</li></ul><p>#ifdef RT_USING_MODULE<br>    void      *module_id;                               &#x2F;<em>*&lt; id of application module *&#x2F;<br>#endif<br>    rt_list_t  list;                                    &#x2F;**&lt; list node of kernel object  双向链表 挂在 对象容器中</em>&#x2F;<br>};<br>typedef struct rt_object *rt_object_t;                  &#x2F;**&lt; Type for kernel objects. *&#x2F;</p><p>4.对象容器结构</p><p> &#x2F;**</p><ul><li>The information of the kernel object<br> *&#x2F;<br>struct rt_object_information<br>{<br> enum rt_object_class_type type;                     &#x2F;<strong>&lt; object class type *&#x2F;<br> rt_list_t                 object_list;              &#x2F;**&lt; object list *&#x2F;<br> rt_size_t                 object_size;              &#x2F;</strong>&lt; object size *&#x2F;<br>};</li></ul><ol start="5"><li>定时器</li></ol><p>  &#x2F;**</p><ul><li><p>timer structure<br> <em>&#x2F;<br>struct rt_timer                                         属于面向对象的思想,子承父类  struct rt_object 是父类<br>{<br> struct rt_object parent;                            &#x2F;**&lt; inherit from rt_object ， 从父类rt_object 继承</em>&#x2F;</p><p> rt_list_t        row[RT_TIMER_SKIP_LIST_LEVEL];</p><p> void (*timeout_func)(void <em>parameter);              &#x2F;**&lt; timeout function                超时函数</em>&#x2F;<br> void            <em>parameter;                         &#x2F;**&lt; timeout function’s parameter    超时函数参数</em>&#x2F;</p><p> rt_tick_t        init_tick;                         &#x2F;<em><em>&lt; timer timeout tick              初始时间 系统节拍</em>&#x2F;<br> rt_tick_t        timeout_tick;                      &#x2F;</em><em>&lt; timeout tick                    超时时间 系统节拍</em>&#x2F;</p></li></ul><p>};<br>typedef struct rt_timer *rt_timer_t;</p><p>6 .线程控制块<br>struct rt_thread                                        属于面向对象的思想,子承父类  struct rt_object 是父类<br>{<br>    &#x2F;* rt object <em>&#x2F;<br>    char        name[RT_NAME_MAX];                      &#x2F;**&lt; the name of thread  头部跟 rt_object 是一样的 继承至 rt_object</em>&#x2F;<br>    rt_uint8_t  type;                                   &#x2F;<em><em>&lt; type of object      内核类型</em>&#x2F;<br>    rt_uint8_t  flags;                                  &#x2F;</em>*&lt; thread’s flags *&#x2F;</p><p>#ifdef RT_USING_MODULE<br>    void       *module_id;                              &#x2F;**&lt; id of application module *&#x2F;<br>#endif</p><pre><code>rt_list_t   list;                                   /**&lt; the object list     注册时插入对象容器中*/rt_list_t   tlist;                                  /**&lt; the thread list     插入在 信号量 线程就绪表等中*//* stack point and entry */void       *sp;                                     /**&lt; stack point         堆栈指针*/void       *entry;                                  /**&lt; entry */void       *parameter;                              /**&lt; parameter */void       *stack_addr;                             /**&lt; stack address */rt_uint32_t stack_size;                             /**&lt; stack size *//* error code */rt_err_t    error;                                  /**&lt; error code */rt_uint8_t  stat;                                   /**&lt; thread status *//* priority */rt_uint8_t  current_priority;                       /**&lt; current priority */rt_uint8_t  init_priority;                          /**&lt; initialized priority */</code></pre><p>#if RT_THREAD_PRIORITY_MAX &gt; 32<br>    rt_uint8_t  number;<br>    rt_uint8_t  high_mask;<br>#endif<br>    rt_uint32_t number_mask;</p><p>#if defined(RT_USING_EVENT)<br>    &#x2F;* thread event *&#x2F;<br>    rt_uint32_t event_set;<br>    rt_uint8_t  event_info;<br>#endif</p><p>#if defined(RT_USING_SIGNALS)<br>    rt_sigset_t     sig_pending;                        &#x2F;**&lt; the pending signals *&#x2F;<br>    rt_sigset_t     sig_mask;                           &#x2F;**&lt; the mask bits of signal *&#x2F;</p><pre><code>void            *sig_ret;                           /**&lt; the return stack pointer from signal */rt_sighandler_t *sig_vectors;                       /**&lt; vectors of signal handler */void            *si_list;                           /**&lt; the signal infor list */</code></pre><p>#endif</p><pre><code>rt_ubase_t  init_tick;                              /**&lt; thread&#39;s initialized tick */rt_ubase_t  remaining_tick;                         /**&lt; remaining tick */struct rt_timer thread_timer;                       /**&lt; built-in thread timer */void (*cleanup)(struct rt_thread *tid);             /**&lt; cleanup function when thread exit *//* light weight process if present */</code></pre><p>#ifdef RT_USING_LWP<br>    void        *lwp;<br>#endif</p><pre><code>rt_uint32_t user_data;                             /**&lt; private user data beyond this thread */</code></pre><p>};<br>typedef struct rt_thread *rt_thread_t;</p><ol start="7"><li>IPC对象, 从 rt_object 继承, IPC主要用于 线程间通信</li></ol><p>&#x2F;**</p><ul><li><p>Base structure of IPC object<br> <em>&#x2F;<br>struct rt_ipc_object<br>{<br> &#x2F;<em>从父类 rt_object 继承</em>&#x2F;                           属于面向对象的思想,子承父类  struct rt_object 是父类<br> struct rt_object parent;                            &#x2F;**&lt; inherit from rt_object   从 rt_object 继承</em>&#x2F;</p><p> rt_list_t        suspend_thread;                    &#x2F;**&lt; threads pended on this resource , 线程请求挂起时会挂在这里 *&#x2F;</p></li></ul><p>};</p><ol start="8"><li>信号量, 线程间通信的内核对象,从 rt_ipc_object 继承<br>&#x2F;**</li></ol><ul><li><p>Semaphore structure<br> <em>&#x2F;<br>struct rt_semaphore<br>{<br> &#x2F;<em>从 父类rt_ipc_object 继承</em>&#x2F;                       属于面向对象的思想,子承父类  struct rt_ipc_object 是父类<br> struct rt_ipc_object parent;                        &#x2F;**&lt; inherit from ipc_object  从 rt_ipc_object 继承</em>&#x2F;</p><p> rt_uint16_t          value;                         &#x2F;<em><em>&lt; value of semaphore.      初始值</em>&#x2F;<br> rt_uint16_t          reserved;                      &#x2F;</em>*&lt; reserved field *&#x2F;</p></li></ul><p>};<br>typedef struct rt_semaphore *rt_sem_t;</p><ol start="9"><li>互斥量, 线程间通信的内核对象,从 rt_ipc_object 继承<br>&#x2F;**</li></ol><ul><li><p>Mutual exclusion (mutex) structure<br> *&#x2F;<br>struct rt_mutex<br>{<br> &#x2F;<em>从 父类rt_ipc_object 继承</em>&#x2F;                        属于面向对象的思想,子承父类  struct rt_ipc_object 是父类<br> struct rt_ipc_object parent;                        &#x2F;**&lt; inherit from ipc_object *&#x2F;</p><p> rt_uint16_t          value;                         &#x2F;**&lt; value of mutex *&#x2F;</p><p> rt_uint8_t           original_priority;             &#x2F;**&lt; priority of last thread hold the mutex *&#x2F;<br> rt_uint8_t           hold;                          &#x2F;**&lt; numbers of thread hold the mutex *&#x2F;</p><p> struct rt_thread    *owner;                         &#x2F;**&lt; current owner of mutex *&#x2F;</p></li></ul><p>};<br>typedef struct rt_mutex *rt_mutex_t;</p><ol start="10"><li>事件，线程间通信的内核对象,从 rt_ipc_object 继承<br>&#x2F;*</li></ol><ul><li><p>event structure<br> *&#x2F;<br>struct rt_event<br>{<br> &#x2F;<em>从父类 rt_ipc_object 继承</em>&#x2F;                        属于面向对象的思想,子承父类  struct rt_ipc_object 是父类<br> struct rt_ipc_object parent;                        &#x2F;**&lt; inherit from ipc_object *&#x2F;</p><p> rt_uint32_t          set;                           &#x2F;**&lt; event set *&#x2F;</p></li></ul><p>};<br>typedef struct rt_event *rt_event_t;</p><ol start="11"><li>邮箱，线程间通信的内核对象,从 rt_ipc_object 继承<br>&#x2F;**</li></ol><ul><li><p>mailbox structure<br> *&#x2F;<br>struct rt_mailbox<br>{<br> &#x2F;<em>从父类 rt_ipc_object 继承</em>&#x2F;                        属于面向对象的思想,子承父类  struct rt_ipc_object 是父类<br> struct rt_ipc_object parent;                        &#x2F;**&lt; inherit from ipc_object *&#x2F;</p><p> rt_uint32_t         *msg_pool;                      &#x2F;**&lt; start address of message buffer *&#x2F;</p><p> rt_uint16_t          size;                          &#x2F;**&lt; size of message pool *&#x2F;</p><p> rt_uint16_t          entry;                         &#x2F;<strong>&lt; index of messages in msg_pool *&#x2F;<br> rt_uint16_t          in_offset;                     &#x2F;**&lt; input offset of the message buffer *&#x2F;<br> rt_uint16_t          out_offset;                    &#x2F;</strong>&lt; output offset of the message buffer *&#x2F;</p><p> rt_list_t            suspend_sender_thread;         &#x2F;**&lt; sender thread suspended on this mailbox *&#x2F;</p></li></ul><p>};<br>typedef struct rt_mailbox *rt_mailbox_t;</p><ol start="12"><li>消息队列，线程间通信的内核对象,从 rt_ipc_object 继承</li></ol><p>&#x2F;**</p><ul><li><p>message queue structure<br> *&#x2F;<br>struct rt_messagequeue<br>{<br> &#x2F;<em>从父类 rt_ipc_object 继承</em>&#x2F;                        属于面向对象的思想,子承父类  struct rt_ipc_object 是父类<br> struct rt_ipc_object parent;                        &#x2F;**&lt; inherit from ipc_object *&#x2F;</p><p> void                *msg_pool;                      &#x2F;**&lt; start address of message queue *&#x2F;</p><p> rt_uint16_t          msg_size;                      &#x2F;**&lt; message size of each message *&#x2F;<br> rt_uint16_t          max_msgs;                      &#x2F;**&lt; max number of messages *&#x2F;</p><p> rt_uint16_t          entry;                         &#x2F;**&lt; index of messages in the queue *&#x2F;</p><p> void                *msg_queue_head;                &#x2F;**&lt; list head *&#x2F;<br> void                *msg_queue_tail;                &#x2F;**&lt; list tail *&#x2F;<br> void                *msg_queue_free;                &#x2F;**&lt; pointer indicated the free node of queue *&#x2F;</p></li></ul><p>};<br>typedef struct rt_messagequeue *rt_mq_t;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;内核对象&lt;br&gt;&amp;#x2F;**&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;The object type can be one of the follows with specific&lt;/li&gt;
&lt;li&gt;macros enabled:&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rtt 内核之重要时间链表</title>
    <link href="http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E9%87%8D%E8%A6%81%E6%97%B6%E9%97%B4%E9%93%BE%E8%A1%A8/"/>
    <id>http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E9%87%8D%E8%A6%81%E6%97%B6%E9%97%B4%E9%93%BE%E8%A1%A8/</id>
    <published>2022-05-22T13:57:25.000Z</published>
    <updated>2022-05-22T13:58:48.802Z</updated>
    
    <content type="html"><![CDATA[<p>用最直接的方式讲解  RTT 定时器的 工作原理, 不讲原理,直接分析代码<br>下面的看懂了，RTT 的定时器也就懂了</p><p>&#x2F;* hard timer list *&#x2F;  这个 RT_TIMER_SKIP_LIST_LEVEL 一般值是 1<br>static rt_list_t rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL];</p><p>static void _rt_timer_init(rt_timer_t timer,<br>                           void (*timeout)(void *parameter),<br>                           void      *parameter,<br>                           rt_tick_t  time,<br>                           rt_uint8_t flag)<br>{<br>    int i;</p><pre><code>/* set flag */timer-&gt;parent.flag  = flag;/* set deactivated */timer-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;timer-&gt;timeout_func = timeout;timer-&gt;parameter    = parameter;timer-&gt;timeout_tick = 0;timer-&gt;init_tick    = time;/* initialize timer list */for (i = 0; i &lt; RT_TIMER_SKIP_LIST_LEVEL; i++)&#123;    rt_list_init(&amp;(timer-&gt;row[i]));&#125;</code></pre><p>}</p><p>rt_inline void _rt_timer_remove(rt_timer_t timer)<br>{<br>    int i;</p><pre><code>for (i = 0; i &lt; RT_TIMER_SKIP_LIST_LEVEL; i++)&#123;    rt_list_remove(&amp;timer-&gt;row[i]);&#125;</code></pre><p>}</p><pre><code> /* init thread timer */</code></pre><p> 在线程初始化时调用<br>   rt_timer_init(&amp;(thread-&gt;thread_timer),<br>                  thread-&gt;name,<br>                  rt_thread_timeout,<br>                  thread,<br>                  0,<br>                  RT_TIMER_FLAG_ONE_SHOT);</p><p>&#x2F;**</p><ul><li><p>This function will initialize a timer, normally this function is used to</p></li><li><p>initialize a static timer object.</p></li><li></li><li><p>@param timer the static timer object</p></li><li><p>@param name the name of timer</p></li><li><p>@param timeout the timeout function</p></li><li><p>@param parameter the parameter of timeout function</p></li><li><p>@param time the tick of timer</p></li><li><p>@param flag the flag of timer<br> *&#x2F;<br>void rt_timer_init(rt_timer_t  timer,<br>            const char *name,<br>            void (*timeout)(void *parameter),<br>            void       <em>parameter,<br>            rt_tick_t   time,<br>            rt_uint8_t  flag)<br>{<br> &#x2F;</em> timer check *&#x2F;<br> RT_ASSERT(timer !&#x3D; RT_NULL);</p><p> &#x2F;* timer object initialization *&#x2F;<br> rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);</p><p> _rt_timer_init(timer, timeout, parameter, time, flag);</p></li></ul><p>}<br>RTM_EXPORT(rt_timer_init);</p><p>定时器结构, 从  struct rt_object 继承<br>struct rt_timer<br>{<br>    struct rt_object parent;                            &#x2F;**&lt; inherit from rt_object *&#x2F;</p><pre><code>rt_list_t        row[RT_TIMER_SKIP_LIST_LEVEL];void (*timeout_func)(void *parameter);              /**&lt; timeout function   定时器超时调用的函数,在线程初始化时赋值为 rt_thread_timeout*/void            *parameter;                         /**&lt; timeout function&#39;s parameter   定时器超时调用，thread*/rt_tick_t        init_tick;                         /**&lt; timer timeout tick   定时器初始化节拍*/rt_tick_t        timeout_tick;                      /**&lt; timeout tick         定时器超时节拍*/</code></pre><p>};<br>typedef struct rt_timer *rt_timer_t;</p><p>这个函数很重要, 线程延时主要是靠这个函数实现, 他的作用是 将 线程按照 超时时间 的先后 挂在 时间链表 rt_timer_list 上面<br>rt_timer_check 函数会扫描  时间链表 rt_timer_list ,然后取出时间到的线程, </p><p>rt_err_t rt_timer_start(rt_timer_t timer)<br>{<br>    unsigned int row_lvl;<br>    rt_list_t *timer_list;<br>    register rt_base_t level;<br>    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];  指针数据, 每个数组元素都是一个指针变量,每个数组元素都指向 rt_list_t *<br>    unsigned int tst_nr;<br>    static unsigned int random_nr;</p><pre><code>/* timer check */RT_ASSERT(timer != RT_NULL);RT_ASSERT(rt_object_get_type(&amp;timer-&gt;parent) == RT_Object_Class_Timer);/* stop timer firstly */level = rt_hw_interrupt_disable();/* remove timer from list */_rt_timer_remove(timer);/* change status of timer */timer-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;rt_hw_interrupt_enable(level);RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&amp;(timer-&gt;parent)));/* * get timeout tick, * the max timeout tick shall not great than RT_TICK_MAX/2 */RT_ASSERT(timer-&gt;init_tick &lt; RT_TICK_MAX / 2);timer-&gt;timeout_tick = rt_tick_get() + timer-&gt;init_tick;   /*重置 超时时间*//* disable interrupt */level = rt_hw_interrupt_disable();</code></pre><p>#ifdef RT_USING_TIMER_SOFT<br>    if (timer-&gt;parent.flag &amp; RT_TIMER_FLAG_SOFT_TIMER)<br>    {<br>        &#x2F;* insert timer to soft timer list <em>&#x2F;<br>        timer_list &#x3D; rt_soft_timer_list;<br>    }<br>    else<br>#endif<br>    {<br>        &#x2F;</em> insert timer to system timer list *&#x2F;<br>        timer_list &#x3D; rt_timer_list;<br>    }</p><p>  获取超时时间链表   rt_timer_list  首地址   重要!!!<br>    row_head[0]  &#x3D; &amp;timer_list[0];  row_head指针数据, 每个数组元素都是一个指针变量,每个数组元素都指向 rt_list_t * 类型的地址<br>    row_head[0] 初始值等于 rt_timer_list,  row_head[0] 会依次扫描 时间链表 rt_timer_list 中的节点，直到找到插入位置<br>    for (row_lvl &#x3D; 0; row_lvl &lt; RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)<br>    {<br>        for (; row_head[row_lvl] !&#x3D; timer_list[row_lvl].prev;<br>             row_head[row_lvl]  &#x3D; row_head[row_lvl]-&gt;next)<br>        {<br>            struct rt_timer *t;<br>            rt_list_t *p &#x3D; row_head[row_lvl]-&gt;next;  获取 时间链表   row_head 后面第一个节点</p><pre><code>        /* fix up the entry pointer */        根据 row 在 定时器rt_timer中的偏移得到 t 的首地址, 即链表p的首地址减去row字段的偏移，然后在去引用 定时器t 其他字段内容        t = rt_list_entry(p, struct rt_timer, row[row_lvl]);            /* If we have two timers that timeout at the same time, it&#39;s         * preferred that the timer inserted early get called early.         * So insert the new timer to the end the the some-timeout timer         * list.         */        如果 需要插入的时间 timer-&gt;timeout_tick 与 链表中节点 p 的时间t-&gt;timeout_tick 相等，跳过,继续插入后面的节点, 遵循先来后到的原则        if ((t-&gt;timeout_tick - timer-&gt;timeout_tick) == 0)          &#123;            continue;        &#125;        如果 需要插入的时间 timer-&gt;timeout_tick 比 链表中节点 p 的时间t-&gt;timeout_tick 小, 则退出for 循环,timer应该插入在节点p的前面        else if ((t-&gt;timeout_tick - timer-&gt;timeout_tick) &lt; RT_TICK_MAX / 2)        &#123;            break;        &#125;    &#125;    由于 RT_TIMER_SKIP_LIST_LEVEL 的值等于1 ,此条件不满足    if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)        row_head[row_lvl + 1] = row_head[row_lvl] + 1;&#125;/* Interestingly, this super simple timer insert counter works very very * well on distributing the list height uniformly. By means of &quot;very very * well&quot;, I mean it beats the randomness of timer-&gt;timeout_tick very easily * (actually, the timeout_tick is not random and easy to be attacked). */random_nr++;tst_nr = random_nr;将 时间 定时器 timer 插入在 节点 p 的前面 即 row_head的后面, row_head 此时指向 prt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - 1],                     &amp;(timer-&gt;row[RT_TIMER_SKIP_LIST_LEVEL - 1])); 由于RT_TIMER_SKIP_LIST_LEVEL==1,                                                                    &amp;(timer-&gt;row[RT_TIMER_SKIP_LIST_LEVEL - 1]) 其实就等于timer-&gt;row的地址条件不满足 不会执行                   for (row_lvl = 2; row_lvl &lt;= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)&#123;    if (!(tst_nr &amp; RT_TIMER_SKIP_LIST_MASK))        rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],                             &amp;(timer-&gt;row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));    else        break;    /* Shift over the bits we have tested. Works well with 1 bit and 2     * bits. */    tst_nr &gt;&gt;= (RT_TIMER_SKIP_LIST_MASK + 1) &gt;&gt; 1;&#125;timer-&gt;parent.flag |= RT_TIMER_FLAG_ACTIVATED;/* enable interrupt */rt_hw_interrupt_enable(level);</code></pre><p>#ifdef RT_USING_TIMER_SOFT<br>    if (timer-&gt;parent.flag &amp; RT_TIMER_FLAG_SOFT_TIMER)<br>    {<br>        &#x2F;* check whether timer thread is ready <em>&#x2F;<br>        if ((timer_thread.stat &amp; RT_THREAD_STAT_MASK) &#x3D;&#x3D; RT_THREAD_SUSPEND)<br>        {<br>            &#x2F;</em> resume timer thread to check soft timer *&#x2F;<br>            rt_thread_resume(&amp;timer_thread);<br>            rt_schedule();<br>        }<br>    }<br>#endif</p><pre><code>return RT_EOK;</code></pre><p>}<br>RTM_EXPORT(rt_timer_start);</p><p>周期性调用, 检查超时时间链表 rt_timer_list 上是否有时间到的项<br>void rt_timer_check(void)<br>{<br>    struct rt_timer *t;<br>    rt_tick_t current_tick;<br>    register rt_base_t level;</p><pre><code>RT_DEBUG_LOG(RT_DEBUG_TIMER, (&quot;timer check enter\n&quot;));current_tick = rt_tick_get();  获取当前系统时间节拍/* disable interrupt */level = rt_hw_interrupt_disable();扫描 时间链表 rt_timer_list , 不为空的情况下while (!rt_list_isempty(&amp;rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))&#123;    排在 时间链表 rt_timer_list 前面的节点永远是最先超时的,取出 rt_timer_list 后面第一个节点判断是否超时,也就是时间到了    t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,                      struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);    /*     * It supposes that the new tick shall less than the half duration of     * tick max.     */    判断定时器节点是否超时    if ((current_tick - t-&gt;timeout_tick) &lt; RT_TICK_MAX / 2)    &#123;        RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t));        /* remove timer from timer list firstly */        从 链表 rt_timer_list 中移除,t 的后面一个节点会前移挂在 rt_timer_list后面,也就是 rt_timer_list 后面第一个节点        _rt_timer_remove(t);        /* call timeout function */        调用 超时函数   rt_thread_timeout ，参数是 thread        t-&gt;timeout_func(t-&gt;parameter);        /* re-get tick */        current_tick = rt_tick_get();        RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t));        RT_DEBUG_LOG(RT_DEBUG_TIMER, (&quot;current tick: %d\n&quot;, current_tick));        if ((t-&gt;parent.flag &amp; RT_TIMER_FLAG_PERIODIC) &amp;&amp;            (t-&gt;parent.flag &amp; RT_TIMER_FLAG_ACTIVATED))        &#123;            /* start it */            如果是周期性的则  重新启动定时器            t-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;            rt_timer_start(t);        &#125;        else        &#123;            /* stop timer */            不是周期性的定时器则关闭,不会再出现在  时间链表 rt_timer_list 上面            t-&gt;parent.flag &amp;= ~RT_TIMER_FLAG_ACTIVATED;        &#125;    &#125;    else        break;&#125;/* enable interrupt */rt_hw_interrupt_enable(level);RT_DEBUG_LOG(RT_DEBUG_TIMER, (&quot;timer check leave\n&quot;));</code></pre><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用最直接的方式讲解  RTT 定时器的 工作原理, 不讲原理,直接分析代码&lt;br&gt;下面的看懂了，RTT 的定时器也就懂了&lt;/p&gt;
&lt;p&gt;&amp;#x2F;* hard timer list *&amp;#x2F;  这个 RT_TIMER_SKIP_LIST_LEVEL 一般值是 1&lt;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rtt 内核之双向链表解析</title>
    <link href="http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%A7%A3%E6%9E%90/</id>
    <published>2022-05-22T13:57:10.000Z</published>
    <updated>2022-05-22T13:58:35.570Z</updated>
    
    <content type="html"><![CDATA[<p>双向链表初始化<br>rt_inline void rt_list_init(rt_list_t *l)<br>{<br>    l-&gt;next &#x3D; l-&gt;prev &#x3D; l;  前后两个节点均初始化为链表起始地址<br>}</p><p>双向链表插入在后面, 即接在后面<br>rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)<br>{<br>    l 是被插入节点,在前    n是需要插入的节点,在后<br>    l-&gt;next-&gt;prev &#x3D; n;    将l 的下一个节点 连在 n上<br>    n-&gt;next &#x3D; l-&gt;next;    将 n 连在 l的下一个节点上</p><pre><code>至此  l的 下一个节点已经和 n 连接好l-&gt;next = n;          将 l 和 n连接n-&gt;prev = l;          将 n 和 l连接</code></pre><p>}</p><p>双向链表插入在前面,即尾部<br>rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)<br>{<br>    l 是被插入节点,在后    n是需要插入的节点,在前</p><pre><code>l-&gt;prev-&gt;next = n;     将 l 的上一个节点和 n连接 , l的上一个节点即尾部n-&gt;prev = l-&gt;prev;     将 n 和l 的上一个节点连接 , l的上一个节点即尾部至此  l的 上一个节点已经和 n 连接好 ,l的上一个节点即尾部，现在 n是尾部了l-&gt;prev = n;           将 l 和 n连接    现在 n是尾部了n-&gt;next = l;           将 n 和 l连接    现在 n是尾部了</code></pre><p>}</p><p>双向链表移除,同时连接  前后两个节点<br>rt_inline void rt_list_remove(rt_list_t *n)<br>{</p><pre><code>n-&gt;next-&gt;prev = n-&gt;prev;   将 n 的下一个节点 和 n 的上一个节点连接  n-&gt;prev-&gt;next = n-&gt;next;   将 n 的上一个节点 和 n 的下一个节点连接n-&gt;next = n-&gt;prev = n;     n 将彻底断开连接</code></pre><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;双向链表初始化&lt;br&gt;rt_inline void rt_list_init(rt_list_t *l)&lt;br&gt;{&lt;br&gt;    l-&amp;gt;next &amp;#x3D; l-&amp;gt;prev &amp;#x3D; l;  前后两个节点均初始化为链表起始地址&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;双向</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rtt 内核之调度相关函数解析</title>
    <link href="http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <id>http://xiaomengk.com/2022/05/22/rtt-%E5%86%85%E6%A0%B8%E4%B9%8B%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/</id>
    <published>2022-05-22T13:56:55.000Z</published>
    <updated>2022-05-22T13:58:23.972Z</updated>
    
    <content type="html"><![CDATA[<p>#include &lt;rtthread.h&gt;<br>#include &lt;rthw.h&gt;</p><p>#ifdef RT_USING_SMP<br>rt_hw_spinlock_t _rt_critical_lock;<br>#endif &#x2F;<em>RT_USING_SMP</em>&#x2F;</p><p>rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];   &#x2F;<em>线程优先级链表, 所有的线程都会安装优先级大小挂在不同的表上面</em>&#x2F;<br>rt_uint32_t rt_thread_ready_priority_group;    &#x2F;<em>优先级就绪分组</em>&#x2F;<br>#if RT_THREAD_PRIORITY_MAX &gt; 32<br>&#x2F;* Maximum priority level, 256 *&#x2F;<br>rt_uint8_t rt_thread_ready_table[32];<br>#endif</p><p>#ifndef RT_USING_SMP<br>extern volatile rt_uint8_t rt_interrupt_nest;<br>static rt_int16_t rt_scheduler_lock_nest;<br>struct rt_thread *rt_current_thread;<br>rt_uint8_t rt_current_priority;<br>#endif &#x2F;<em>RT_USING_SMP</em>&#x2F;</p><p>rt_list_t rt_thread_defunct;</p><p>获取 最高优先级的线程<br>static struct rt_thread* _get_highest_priority_thread(rt_ubase_t *highest_prio)<br>{<br>    register struct rt_thread *highest_priority_thread;<br>    register rt_ubase_t highest_ready_priority;</p><p>#if RT_THREAD_PRIORITY_MAX &gt; 32<br>    register rt_ubase_t number;</p><pre><code>number = __rt_ffs(rt_thread_ready_priority_group) - 1;highest_ready_priority = (number &lt;&lt; 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;</code></pre><p>#else<br>    highest_ready_priority &#x3D; __rt_ffs(rt_thread_ready_priority_group) - 1;  &#x2F;<em>利用位图算法找到最高优先级的 线程,也就是数字最小的</em>&#x2F;<br>#endif</p><pre><code>/* get highest ready priority thread */highest_priority_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,                          struct rt_thread,                          tlist);   /*获取线程控制块的首地址*/*highest_prio = highest_ready_priority;  /*返回最高的优先级*/return highest_priority_thread;</code></pre><p>}</p><p>&#x2F;**</p><ul><li><p>@ingroup SystemInit</p></li><li><p>This function will startup scheduler. It will select one thread</p></li><li><p>with the highest priority level, then switch to it.<br> *&#x2F;<br>void rt_system_scheduler_start(void)<br>{<br> register struct rt_thread *to_thread;<br> rt_ubase_t highest_ready_priority;</p><p> to_thread &#x3D; _get_highest_priority_thread(&amp;highest_ready_priority);</p></li></ul><p>#ifdef RT_USING_SMP<br>    to_thread-&gt;oncpu &#x3D; rt_hw_cpu_id();<br>#else<br>    rt_current_thread &#x3D; to_thread;<br>#endif &#x2F;<em>RT_USING_SMP</em>&#x2F;</p><pre><code>rt_schedule_remove_thread(to_thread);to_thread-&gt;stat = RT_THREAD_RUNNING;/* switch to new thread */</code></pre><p>#ifdef RT_USING_SMP<br>    rt_hw_context_switch_to((rt_ubase_t)&amp;to_thread-&gt;sp, to_thread);<br>#else<br>    rt_hw_context_switch_to((rt_ubase_t)&amp;to_thread-&gt;sp);<br>#endif &#x2F;<em>RT_USING_SMP</em>&#x2F;</p><pre><code>/* never come back */</code></pre><p>}</p><p>&#x2F;**</p><ul><li>@addtogroup Thread<br> *&#x2F;</li></ul><p>&#x2F;**@{*&#x2F;</p><p>&#x2F;**</p><ul><li><p>This function will perform one schedule. It will select one thread</p></li><li><p>with the highest priority level, then switch to it.<br> *&#x2F;<br>void rt_schedule(void)<br>{<br> rt_base_t level;<br> struct rt_thread *to_thread;<br> struct rt_thread *from_thread;</p><p> &#x2F;* disable interrupt *&#x2F;<br> level &#x3D; rt_hw_interrupt_disable();</p><p> &#x2F;* check the scheduler is enabled or not <em>&#x2F;<br> if (rt_scheduler_lock_nest &#x3D;&#x3D; 0)   &#x2F;<em>调度没有上锁,即可以进行调度</em>&#x2F;<br> {<br> rt_ubase_t highest_ready_priority;<br><br> if (rt_thread_ready_priority_group !&#x3D; 0)   &#x2F;<em>有就绪的线程才能进行调度</em>&#x2F;<br> {<br>     &#x2F;</em> need_insert_from_thread: need to insert from_thread to ready queue <em>&#x2F;<br>     int need_insert_from_thread &#x3D; 0;<br><br>     to_thread &#x3D; _get_highest_priority_thread(&amp;highest_ready_priority);&#x2F;<em>获取优先级最高的线程控制块首地址</em>&#x2F;<br><br>     if ((rt_current_thread-&gt;stat &amp; RT_THREAD_STAT_MASK) &#x3D;&#x3D; RT_THREAD_RUNNING) &#x2F;<em>当前的线程是否在运行状态</em>&#x2F;<br>     {<br>         if (rt_current_thread-&gt;current_priority &lt; highest_ready_priority) &#x2F;*当前在运行的线程 优先级是否比 highest_ready_priority 高*&#x2F;<br>         {<br>             to_thread &#x3D; rt_current_thread;  &#x2F;*系统中优先级最高线程的依然是 rt_current_thread*&#x2F;<br>         }<br>         else<br>         {<br>             need_insert_from_thread &#x3D; 1;    &#x2F;*系统中优先级最高线程是to_thread, 需要插入*&#x2F;<br>         }<br>     }<br>     &#x2F;*to_thread 不等于 当前正在运行的线程 rt_current_thread, 说明需要调度,需要切换至高优先级线程to_thread *&#x2F;<br>     if (to_thread !&#x3D; rt_current_thread)<br>     {<br>         &#x2F;* if the destination thread is not the same as current thread *&#x2F;<br>         rt_current_priority &#x3D; (rt_uint8_t)highest_ready_priority;  &#x2F;*将最高优先级赋给 rt_current_priority*&#x2F;<br>         from_thread         &#x3D; rt_current_thread;   &#x2F;* 从 当前正在运行的线程 rt_current_thread 切换 *&#x2F;<br>         rt_current_thread   &#x3D; to_thread;           &#x2F;* 切换至 系统最高优先级线程to_thread *&#x2F;<br><br>         RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));<br><br>         if (need_insert_from_thread)<br>         {<br>             &#x2F;*线程from_thread已不在线程就绪表中, 将 from_thread 线程 插入线程就绪表尾部,等待下次调度 *&#x2F;<br>             rt_schedule_insert_thread(from_thread);<br>         }<br>         &#x2F;*将 需要调度的线程 to_thread 从线程就绪表中移除,马上进入运行状态,不参与线程调度 *&#x2F;<br>         rt_schedule_remove_thread(to_thread);<br><br>         &#x2F;*将线程 to_thread 设置为运行状态*&#x2F;<br>         to_thread-&gt;stat &#x3D; RT_THREAD_RUNNING | (to_thread-&gt;stat &amp; ~RT_THREAD_STAT_MASK);<br><br>         &#x2F;</em> switch to new thread *&#x2F;<br>         RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,<br>                 (“[%d]switch to priority#%d “<br>                  “thread:%.*s(sp:0x%08x), “<br>                  “from thread:%.*s(sp: 0x%08x)\n”,<br>                  rt_interrupt_nest, highest_ready_priority,<br>                  RT_NAME_MAX, to_thread-&gt;name, to_thread-&gt;sp,<br>                  RT_NAME_MAX, from_thread-&gt;name, from_thread-&gt;sp));</p></li></ul><p>#ifdef RT_USING_OVERFLOW_CHECK<br>                _rt_scheduler_stack_check(to_thread);<br>#endif</p><pre><code>            if (rt_interrupt_nest == 0)            &#123;                extern void rt_thread_handle_sig(rt_bool_t clean_state);                                /*从线程 from_thread 切换至 线程to_thread*/                rt_hw_context_switch((rt_ubase_t)&amp;from_thread-&gt;sp,                        (rt_ubase_t)&amp;to_thread-&gt;sp);</code></pre><p>#ifdef RT_USING_SIGNALS<br>                    if (rt_current_thread-&gt;stat &amp; RT_THREAD_STAT_SIGNAL_PENDING)<br>                    {<br>                        extern void rt_thread_handle_sig(rt_bool_t clean_state);</p><pre><code>                    rt_current_thread-&gt;stat &amp;= ~RT_THREAD_STAT_SIGNAL_PENDING;                    rt_hw_interrupt_enable(level);                    /* check signal status */                    rt_thread_handle_sig(RT_TRUE);                &#125;                else                &#123;                    rt_hw_interrupt_enable(level);                &#125;</code></pre><p>#else<br>                    &#x2F;* enable interrupt *&#x2F;<br>                    rt_hw_interrupt_enable(level);<br>#endif<br>                    goto __exit;<br>                }<br>                else<br>                {<br>                    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (“switch in interrupt\n”));</p><pre><code>                rt_hw_context_switch_interrupt((rt_ubase_t)&amp;from_thread-&gt;sp,                        (rt_ubase_t)&amp;to_thread-&gt;sp);            &#125;        &#125;        else        &#123;            rt_schedule_remove_thread(rt_current_thread);            rt_current_thread-&gt;stat = RT_THREAD_RUNNING | (rt_current_thread-&gt;stat &amp; ~RT_THREAD_STAT_MASK);        &#125;    &#125;&#125;/* enable interrupt */rt_hw_interrupt_enable(level);</code></pre><p>__exit:<br>    return;<br>}</p><p>线程插入<br>线程插入和移除主要是操作 线程控制块 rt_thread 中的 字段tlist,这是一个双向链表, 他可能挂在的地方有两个<br>1 是线程就绪链表 rt_thread_priority_table 中,此时线程是处于就绪态或者运行态<br>2 是 IPC 对象中, 即挂在 rt_ipc_object中的  suspend_thread 字段上, 此时线程处于挂起状态，IPC 对象被 信号量等内核对象继承<br>void rt_schedule_insert_thread(struct rt_thread *thread)<br>{<br>    register rt_base_t temp;</p><pre><code>RT_ASSERT(thread != RT_NULL);/* disable interrupt */temp = rt_hw_interrupt_disable();/* it&#39;s current thread, it should be RUNNING thread */if (thread == rt_current_thread)&#123;    thread-&gt;stat = RT_THREAD_RUNNING | (thread-&gt;stat &amp; ~RT_THREAD_STAT_MASK);    goto __exit;&#125;/* READY thread, insert to ready queue *//*将线程 thread 状态设置为 就绪态*/thread-&gt;stat = RT_THREAD_READY | (thread-&gt;stat &amp; ~RT_THREAD_STAT_MASK);/* insert thread to ready list *//*将 线程 thread 插入到就绪链表 rt_thread_priority_table 尾部*/rt_list_insert_before(&amp;(rt_thread_priority_table[thread-&gt;current_priority]),                      &amp;(thread-&gt;tlist));RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (&quot;insert thread[%.*s], the priority: %d\n&quot;,                                  RT_NAME_MAX, thread-&gt;name, thread-&gt;current_priority));/* set priority mask */</code></pre><p>#if RT_THREAD_PRIORITY_MAX &gt; 32<br>    rt_thread_ready_table[thread-&gt;number] |&#x3D; thread-&gt;high_mask;<br>#endif<br>    rt_thread_ready_priority_group |&#x3D; thread-&gt;number_mask;</p><p>__exit:<br>    &#x2F;* enable interrupt *&#x2F;<br>    rt_hw_interrupt_enable(temp);<br>}</p><p>线程移除<br>线程插入和移除主要是操作 线程控制块 rt_thread 中的 字段tlist,这是一个双向链表, 他可能挂在的地方有两个<br>1 是线程就绪链表 rt_thread_priority_table 中,此时线程是处于就绪态或者运行态<br>2 是 IPC 对象中, 即挂在 rt_ipc_object中的  suspend_thread 字段上, 此时线程处于挂起状态，IPC 对象被 信号量等内核对象继承<br>void rt_schedule_remove_thread(struct rt_thread *thread)<br>{<br>    register rt_base_t level;</p><pre><code>RT_ASSERT(thread != RT_NULL);/* disable interrupt */level = rt_hw_interrupt_disable();RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (&quot;remove thread[%.*s], the priority: %d\n&quot;,                                  RT_NAME_MAX, thread-&gt;name,                                  thread-&gt;current_priority));/* remove thread from ready list *//*将线程 thread 从 就绪链表 rt_thread_priority_table 中移除, 主要是将线程控制块 thread 的 链表 tlist从就绪表中移除,同时连接该链表上下的节点*/rt_list_remove(&amp;(thread-&gt;tlist));if (rt_list_isempty(&amp;(rt_thread_priority_table[thread-&gt;current_priority])))&#123;</code></pre><p>#if RT_THREAD_PRIORITY_MAX &gt; 32<br>        rt_thread_ready_table[thread-&gt;number] &amp;&#x3D; ~thread-&gt;high_mask;<br>        if (rt_thread_ready_table[thread-&gt;number] &#x3D;&#x3D; 0)<br>        {<br>            rt_thread_ready_priority_group &amp;&#x3D; ~thread-&gt;number_mask;<br>        }<br>#else<br>        rt_thread_ready_priority_group &amp;&#x3D; ~thread-&gt;number_mask;<br>#endif<br>    }</p><pre><code>/* enable interrupt */rt_hw_interrupt_enable(level);</code></pre><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#include &amp;lt;rtthread.h&amp;gt;&lt;br&gt;#include &amp;lt;rthw.h&amp;gt;&lt;/p&gt;
&lt;p&gt;#ifdef RT_USING_SMP&lt;br&gt;rt_hw_spinlock_t _rt_critical_lock;&lt;br&gt;#endif &amp;#x2F;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lwip RTT测量</title>
    <link href="http://xiaomengk.com/2022/05/13/lwip-RTT%E6%B5%8B%E9%87%8F/"/>
    <id>http://xiaomengk.com/2022/05/13/lwip-RTT%E6%B5%8B%E9%87%8F/</id>
    <published>2022-05-13T10:28:37.000Z</published>
    <updated>2022-05-23T12:37:06.415Z</updated>
    
    <content type="html"><![CDATA[<p>RTT学习笔记: </p><p>1.2、lwip RTT测量<br>lwip RTT测量涉及rttest、rtseq、sa、sv变量，rttest为报文发送的时间，，rtseq为测量往返时间报文的序号，sa(rtt average estimator)、sv(rtt deviation estimator)为计算往返时间的变量。<br>————————————————<br>版权声明：本文为CSDN博主「arm7star」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/arm7star/article/details/117199104">https://blog.csdn.net/arm7star/article/details/117199104</a></p><p>sa : 平均估计量<br>sv : 偏差估计量</p><pre><code>                                Err = M-A                                        （1）                                A = A+ g* Err                                    （2）                                D =D + h *  (|Err|-D)                            （3）                                RTO = A+4*D                                      （4）    其中M表示某次测量的RTT的值，A表示测得的RTT的平均值，A值的更新如第二式所示，D值为RTT的估计的方差，其更新如第三式所示。二式和三式中g和h都为常数，一般g取1/8，h取1/4。这样取值是为了便于计算，从后面可以看出，通过简单的移位操作就可以完成上述计算了。RTO的计算如第四式所示，初始时，RTO取值为6，即3s，A值为0，D值为6。</code></pre><p>公式推导:</p><p>其中M表示某次测量的RTT的值，A表示测得的RTT的平均值，A值的更新如第二式所示，D值为RTT的估计的方差，其更新如第三式所示。二式和三式中g和h都为常数，一般g取1&#x2F;8，h取1&#x2F;4。这样取值是为了便于计算，从后面可以看出，通过简单的移位操作就可以完成上述计算了。RTO的计算第四式所示，初始时，RTO取值为6，即3s，A值为0，D值为6。</p><p>现在我们将上面的四个表达式做简单的变化，就得到了LWIP中计算RTT的表达式：<br>————————————————<br>版权声明：本文为CSDN博主「weixin_40004057」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_40004057/article/details/111966128">https://blog.csdn.net/weixin_40004057/article/details/111966128</a></p><pre><code>    Err = M-A                     (1)    /* 测量值M - 平均值A = Err*/    A = A+ Err/8                  (2)    A = A+(M-A)/8                 (3)由(3)式两边同时 乘以8 可知:    8A = 8A +M-A                  (4)令sa = 8A, A=sa/8 =sa&gt;&gt;3    sa = sa + M -sa&gt;&gt;3            (5)    D =D + (|Err |-D)/4           (6)    D = D + (|M-A|-D)/4           (7)    由(3)式两边同时 乘以4 可知:   4D = 4D + (|M-A |-D)           (8)令sv =4D, D=sv/4=sv&gt;&gt;2   sv = sv + (|M-sa&gt;&gt;3|-sv&gt;&gt;2)    (9)   RTO = A+4D                     (10)    RTO = sa&gt;&gt;3 + sv               (11)</code></pre><p>  相关字段解释: </p><pre><code>rtime     /*用于重传定时器的计数，当其值为-1时表示计数器未被使能；当值为非0时表示计数器使能，在这种情况下，rtime的值每500ms被内核加1，          当rtime超过rto的值时，在unacked队列上的所有数据段将被重传*/rttest    /*设置为tcp_ticks, 即调用 tcp_output_segment 函数发送报文时, 设置 起始时间  pcb-&gt;rttest = tcp_ticks;*/rtseq     /*记录要进行RTT估计的数据段的起始数据编号,调用 tcp_output_segment 函数发送报文时 设置 pcb-&gt;rtseq = lwip_ntohl(seg-&gt;tcphdr-&gt;seqno);*/rto       /* 为数据包所设置的超时重传时间 */sa        /*平均估计量, 计算 rto */sv        /*偏差估计量, 计算 rto */nrtx     /*重传次数 rto值以2的指数倍退让*/</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RTT学习笔记: &lt;/p&gt;
&lt;p&gt;1.2、lwip RTT测量&lt;br&gt;lwip RTT测量涉及rttest、rtseq、sa、sv变量，rttest为报文发送的时间，，rtseq为测量往返时间报文的序号，sa(rtt average estimator)、sv(rtt de</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo + next 搭建个人博客笔记</title>
    <link href="http://xiaomengk.com/2022/05/12/hexo-next-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/"/>
    <id>http://xiaomengk.com/2022/05/12/hexo-next-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-12T12:00:12.000Z</published>
    <updated>2022-05-26T13:42:00.847Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>修改代码区主题</p><p>   站点_config.yml<br>   highlight:<br>   enable: true<br>   line_number: true<br>   auto_detect: true<br>   tab_replace:<br>  文字自动检测默认不启动，所以改成true使其起作用</p><p>  主题_config.yml<br>  highlight_theme: normal<br>  normal<br>  night<br>  night eighties<br>  night blue<br>  night bright</p></li><li><p>D:\Program Files\Blog\themes\next\source\css_custom\styles.styl<br>.footer-inner {color: #ffb6c1;}  &#x2F;&#x2F;改变页脚字体颜色</p><p>&#x2F;&#x2F; Custom styles.<br> code {<br> color: #ff7600;<br> background: #fbf7f8;<br> margin: 2px;<br> color: #228B22 !important;  &#x2F;&#x2F;设置代码颜色<br> }</p></li><li><p>链接<br>   从零开始搭建个人博客（超详细）<br>   <a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a><br><br>   博客写作攻略–Hexo+Github+Netlify+CMS<br>   <a href="https://zhuanlan.zhihu.com/p/77651304">https://zhuanlan.zhihu.com/p/77651304</a><br><br>   Netlify搭建个人博客设置域名<br>   <a href="https://blog.csdn.net/mqdxiaoxiao/article/details/96365253">https://blog.csdn.net/mqdxiaoxiao/article/details/96365253</a><br><br>   修改 hexo-theme-next 主题的样式（统一网站颜色）<br>   <a href="https://www.jianshu.com/p/2a8d399f1266">https://www.jianshu.com/p/2a8d399f1266</a><br><br>   Hexo NexT 主题美化记录<br>   <a href="https://www.jianshu.com/p/64caf29fdd0c">https://www.jianshu.com/p/64caf29fdd0c</a><br><br>   hexo+next个性化配置<br>   <a href="https://zhuanlan.zhihu.com/p/129644138">https://zhuanlan.zhihu.com/p/129644138</a><br><br>   给hexo主题添加背景及更改字体颜色（next的Mist主题）<br>   <a href="https://blog.csdn.net/weixin_40837922/article/details/88047241">https://blog.csdn.net/weixin_40837922/article/details/88047241</a><br><br>   Netlify 官网<br>   <a href="https://app.netlify.com/">https://app.netlify.com/</a><br><br>   Hexo博客开发之——Github绑定Netlify改动代码后自动部署<br>   <a href="https://blog.csdn.net/Calvin_zhou/article/details/109447074">https://blog.csdn.net/Calvin_zhou/article/details/109447074</a><br><br>   Hexo NexT主题自定义背景图片<br>   <a href="https://blog.csdn.net/qq_52116176/article/details/109406842">https://blog.csdn.net/qq_52116176/article/details/109406842</a>         </p></li><li><p>更换SITE-TITLE及MENU字体颜色</p><p>找到博客目录下D:\Program Files\Blog\themes\next\source\css_common\outline\header\site-meta.styl文件，在.brand{}里添加以下代码：<br>color: #ffb6c1 !important;</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改代码区主题&lt;/p&gt;
&lt;p&gt;   站点_config.yml&lt;br&gt;   highlight:&lt;br&gt;   enable: true&lt;br&gt;   line_number: true&lt;br&gt;   auto_detect: true&lt;br&gt;   tab_re</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP中的数据结构</title>
    <link href="http://xiaomengk.com/2022/05/12/TCP%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://xiaomengk.com/2022/05/12/TCP%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-05-12T10:39:14.000Z</published>
    <updated>2022-05-12T12:10:05.431Z</updated>
    
    <content type="html"><![CDATA[<p>前言:  这是我最近学习Lwip 整理的TCP相关的数据结构, 与大家分享</p><p>一。TCP_PCB 结构<br>      &#x2F;*与其他协议一样，为了描述 TCP 协议， LwIP 定义了一个名字叫 tcp_pcb 的结构体，我们称之为<br>      TCP 控制块，其内定义了大量的成员变量，基本定义了整个 TCP 协议运作过程的所有需要的东<br>      西，如发送窗口、接收窗口、数据缓冲区。超时处理、拥塞控制、滑动窗口等等，具体见代码清<br>      单 13_3。<br>      代码清单 13‑3 TCP 控制块<br>      <em>&#x2F;<br>      #define IP_PCB <br>      &#x2F;</em> 本地 ip 地址与远端 IP 地址 <em>&#x2F; <br>      ip_addr_t local_ip; <br>      ip_addr_t remote_ip; <br>      &#x2F;</em> 绑定 netif 索引 <em>&#x2F; <br>      u8_t netif_idx; <br>      &#x2F;</em> 套接字选项 <em>&#x2F; <br>      u8_t so_options; <br>      &#x2F;</em> 服务类型 <em>&#x2F; <br>      u8_t tos; <br>      &#x2F;</em> 生存时间 <em>&#x2F; <br>      u8_t ttl <br>      &#x2F;</em> 链路层地址解析提示 *&#x2F; <br>      IP_PCB_NETIFHINT<br>      #define TCP_PCB_COMMON(type) <br>      type <em>next; &#x2F;</em> 指向链表中的下一个控制块 *&#x2F; <br>      void <em>callback_arg; <br>      TCP_PCB_EXTARGS <br>      enum tcp_state state; &#x2F;</em> TCP 状态 *&#x2F; \</p><pre><code>  u8_t prio; \  /* 本地主机端口号 */ \  u16_t local_port  /** TCP 协议控制块 */  struct tcp_pcb  &#123;  IP_PCB;  /** 协议特定的 PCB 成员 */  TCP_PCB_COMMON(struct tcp_pcb);  /* 远端端口号 */  u16_t remote_port;  tcpflags_t flags;  #define TF_ACK_DELAY 0x01U /* 延迟发送 ACK */  #define TF_ACK_NOW 0x02U /* 立即发送 ACK. */  #define TF_INFR 0x04U /* 在快速恢复。 */  #define TF_CLOSEPEND 0x08U /* 关闭挂起 */  #define TF_RXCLOSED 0x10U /* rx 由 tcp_shutdown 关闭 */  #define TF_FIN 0x20U /* 连接在本地关闭 */  #define TF_NODELAY 0x40U /* 禁用 Nagle 算法 */  #define TF_NAGLEMEMERR 0x80U /* 本地缓冲区溢出 */  #define TF_TIMESTAMP 0x0400U /* Timestamp option enabled */  #endif  #define TF_RTO 0x0800U /* RTO 计时器 */  u8_t polltmr, pollinterval;  u8_t last_timer;  /* 控制块被最后一次处理的时间 */  u32_t tmr;     /* 该字段记录该PCB被创建的时刻 */    /* 接收窗口相关的字段 */  u32_t rcv_nxt; /* 下一个期望收到的序号 */  tcpwnd_size_t rcv_wnd; /* 接收窗口大小 */  tcpwnd_size_t rcv_ann_wnd; /* 告诉对方窗口的大小 */  u32_t rcv_ann_right_edge; /* 窗口的右边缘 */  /* 重传计时器。 */  s16_t rtime;    /*重传定时，该值随时间增加，当大于rto的值时则重传发生*/  u16_t mss;  /* 最大报文段大小 1460 , MSS是TCP报文段中的数据字段的最大长度  MSS=TCP报文段长度-TCP首部长度*/  /* RTT（往返时间）估计变量 */  u32_t rttest; /* RTT 估计，以为 500 毫秒递增 */  u32_t rtseq; /* 用于测试 RTT 的报文段序号 */  s16_t sa, sv; /* RTT 估计得到的平均值与时间差 */  s16_t rto; /* 重传超时 */  u8_t nrtx; /* 重传次数 */  /* 快速重传/恢复 */  u8_t dupacks;  u32_t lastack; /* 接收到的最大确认序号 */  /* 拥塞避免/控制变量 */  tcpwnd_size_t cwnd; /* 连接当前的窗口大小, 拥塞窗口 */  tcpwnd_size_t ssthresh; /* 拥塞避免算法启动的阈值, 拥塞慢开始门限 */  u32_t rto_end;  u32_t snd_nxt; /* 下一个要发送的序号 , 从以太网链路层发出*/  u32_t snd_wl1, snd_wl2; /* 上一次收到的序号和确认号 */  u32_t snd_lbb; /* 要缓冲的下一个字节的序列号 ,缓存至pcb-&gt;unsent中*/  tcpwnd_size_t snd_wnd; /* 发送窗口大小 */  tcpwnd_size_t snd_wnd_max; /* 对方的最大发送方窗口 */  /* 可用的缓冲区空间（以字节为单位）。 */  tcpwnd_size_t snd_buf;  tcpwnd_size_t bytes_acked;  struct tcp_seg *unsent; /* 未发送的报文段 */  struct tcp_seg *unacked; /* 已发送但未收到确认的报文段 */  struct tcp_seg *ooseq; /* 已收到的无序报文 */  /* 以前收到但未被上层处理的数据 */  struct pbuf *refused_data;  #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG  struct tcp_pcb_listen* listener;  #endif  //TCP 协议相关的回调函数  #if LWIP_CALLBACK_API  /* 当数据发送成功后被调用 */  tcp_sent_fn sent;  /* 接收数据完成后被调用 */  tcp_recv_fn recv;  /* 建立连接后被调用 */  tcp_connected_fn connected;  /* 该函数被内核周期调用 */  tcp_poll_fn poll;  /* 发送错误时候被调用 */  tcp_err_fn errf;  /* 保持活性 */  u32_t keep_idle;  /* 坚持计时器计数器值 */  u8_t persist_cnt;               /*(persist_cnt ++) ==(persist_backoff)*/  u8_t persist_backoff;           /*坚持定时器关闭与打开*/  u8_t persist_probe;             /*TCP 零窗口探测次数*/  /* 保持活性报文发送次数 */  u8_t keep_cnt_sent;  &#125;;  1. /*persist_probe 在 tcp_zero_window_probe(struct tcp_pcb *pcb) 中自增 */  报文结构:    eth_hdr(14)     ip_hdr(20)       tcp_hdr(20)        APP应用层数据域    以太网帧     +    IP头      +     TCP 头        +   最大数据长度      14              20              20                1460</code></pre><p>二。PBUF 结构     &#x2F;<em>专为以太网报文设计</em>&#x2F;<br>    &#x2F;** Main packet buffer struct <em>&#x2F;<br>    struct pbuf {<br>      &#x2F;</em>* next pbuf in singly linked pbuf chain *&#x2F;<br>      struct pbuf *next;</p><pre><code>  /** pointer to the actual data in the buffer */  void *payload;                                                     /*  指向数据域  */  /**   * total length of this buffer and all next buffers in chain   * belonging to the same packet.   *   * For non-queue packet chains this is the invariant:   * p-&gt;tot_len == p-&gt;len + (p-&gt;next? p-&gt;next-&gt;tot_len: 0)   */  u16_t tot_len;  /** length of this buffer */  u16_t len;                                                         /*  payload  所指向的数据域长度  */  /** a bit field indicating pbuf type and allocation sources      (see PBUF_TYPE_FLAG_*, PBUF_ALLOC_FLAG_* and PBUF_TYPE_ALLOC_SRC_MASK)    */  u8_t type_internal;                                               /*  PBUF_REF  PBUF_ROM  PBUF_POOL  PBUF_RAM */  /** misc flags */  u8_t flags;  /**   * the reference count always equals the number of pointers   * that refer to this pbuf. This can be pointers from an application,   * the stack itself, or pbuf-&gt;next pointers from a chain.   */  LWIP_PBUF_REF_T ref;  /** For incoming packets, this contains the input netif&#39;s index */  u8_t if_idx;&#125;;struct pbuf *p =  (struct pbuf *)mem_malloc(alloc_len);p所指向的内存包括三部分  --&gt;&gt;                                (1)  sizeof(struct pbuf)                                               +                                (2)  offset( (以太网头 14 byte) + (IP 头 20byte) + (TCP 头 20 byte) )  +                              (3)  应用层数据部分, 也就是 payload字段指向的内存p-&gt;payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + sizeof(struct pbuf) + offset)p-&gt;len = payload字段指向的内存， 即数据域长度p-&gt;tot_len = 数据域总长度#define PBUF_LINK_ENCAPSULATION_HLEN    0#define PBUF_LINK_HLEN                  16    链路层    eth_hdr(14)#define PBUF_IP_HLEN                    20    IP 层     ip_hdr(20)#define PBUF_TRANSPORT_HLEN             20    TCP 层    tcp_hdr(20)typedef enum &#123;  /** Includes spare room for transport layer header, e.g. UDP header.   * Use this if you intend to pass the pbuf to functions like udp_send().   */  PBUF_TRANSPORT = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN,  /** Includes spare room for IP header.   * Use this if you intend to pass the pbuf to functions like raw_send().   */  PBUF_IP = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN,  /** Includes spare room for link layer header (ethernet header).   * Use this if you intend to pass the pbuf to functions like ethernet_output().   * @see PBUF_LINK_HLEN   */  PBUF_LINK = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN,  /** Includes spare room for additional encapsulation header before ethernet   * headers (e.g. 802.11).   * Use this if you intend to pass the pbuf to functions like netif-&gt;linkoutput().   * @see PBUF_LINK_ENCAPSULATION_HLEN   */  PBUF_RAW_TX = PBUF_LINK_ENCAPSULATION_HLEN,  /** Use this for input packets in a netif driver when calling netif-&gt;input()   * in the most common case - ethernet-layer netif driver. */  PBUF_RAW = 0                                                                      /* 此pbuf 只有数据,没有报头  sizeof(struct pbuf) + 报文数据*/&#125; pbuf_layer;    这个结构就是  payload字段前的 offset 偏移</code></pre><p>三。TCP_SEG 结构</p><pre><code>/* This structure represents a TCP segment on the unsent, unacked and ooseq queues */struct tcp_seg &#123;  struct tcp_seg *next;    /* used when putting segments on a queue */  struct pbuf *p;          /* buffer containing data + TCP header */     指向 struct pbuf * 整个报文段 , 以太网最大报文段长度1516, payload指向TCP报文首部  u16_t len;               /* the TCP length of this segment */          应用层数据长度, 不包括  eth_hdr(14) + ip_hdr(20) + tcp_hdr(20)，最大1460#if TCP_OVERSIZE_DBGCHECK  u16_t oversize_left;     /* Extra bytes available at the end of the last                              pbuf in unsent (used for asserting vs.                              tcp_pcb.unsent_oversize only) */#endif /* TCP_OVERSIZE_DBGCHECK */#if TCP_CHECKSUM_ON_COPY  u16_t chksum;  u8_t  chksum_swapped;#endif /* TCP_CHECKSUM_ON_COPY */  u8_t  flags;#define TF_SEG_OPTS_MSS         (u8_t)0x01U /* Include MSS option (only used in SYN segments) */#define TF_SEG_OPTS_TS          (u8_t)0x02U /* Include timestamp option. */#define TF_SEG_DATA_CHECKSUMMED (u8_t)0x04U /* ALL data (not the header) is                                              checksummed into &#39;chksum&#39; */#define TF_SEG_OPTS_WND_SCALE   (u8_t)0x08U /* Include WND SCALE option (only used in SYN segments) */#define TF_SEG_OPTS_SACK_PERM   (u8_t)0x10U /* Include SACK Permitted option (only used in SYN segments) */  struct tcp_hdr *tcphdr;  /* the TCP header */                      指向   tcp_hdr 头, TCP 头部&#125;;四.struct tcp_hdr &#123;  PACK_STRUCT_FIELD(u16_t src);  PACK_STRUCT_FIELD(u16_t dest);  PACK_STRUCT_FIELD(u32_t seqno);  PACK_STRUCT_FIELD(u32_t ackno);  PACK_STRUCT_FIELD(u16_t _hdrlen_rsvd_flags);  PACK_STRUCT_FIELD(u16_t wnd);  PACK_STRUCT_FIELD(u16_t chksum);  PACK_STRUCT_FIELD(u16_t urgp);&#125; PACK_STRUCT_STRUCT; </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言:  这是我最近学习Lwip 整理的TCP相关的数据结构, 与大家分享&lt;/p&gt;
&lt;p&gt;一。TCP_PCB 结构&lt;br&gt;      &amp;#x2F;*与其他协议一样，为了描述 TCP 协议， LwIP 定义了一个名字叫 tcp_pcb 的结构体，我们称之为&lt;br&gt;      </summary>
      
    
    
    
    
  </entry>
  
</feed>
